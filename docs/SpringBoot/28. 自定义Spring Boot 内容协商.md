**<font style="color:rgb(76, 73, 72);">内容协商</font>**<font style="color:rgb(76, 73, 72);">机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。HTTP请求头中Content-Type，Accept等内容就是内容协商判断的标准。在Spring Boot中，一个完整的内容协商过程如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713469608-9005d031-dece-4b29-9d96-a53864d91870.png)

<font style="color:rgb(76, 73, 72);">这个过程的核心组件：</font>

| **<font style="color:rgb(76, 73, 72);">组件</font>** | **<font style="color:rgb(76, 73, 72);">名称</font>** | **<font style="color:rgb(76, 73, 72);">说明</font>** |
| :--- | :--- | :--- |
| <font style="color:rgb(76, 73, 72);">ContentNegotiationManager</font> | <font style="color:rgb(76, 73, 72);">内容协商管理器</font> | <font style="color:rgb(76, 73, 72);">ContentNegotiationStrategy 控制策略</font> |
| <font style="color:rgb(76, 73, 72);">MediaType</font> | <font style="color:rgb(76, 73, 72);">媒体类型</font> | <font style="color:rgb(76, 73, 72);">HTTP 消息媒体类型，如 text/html</font> |
| <font style="color:rgb(76, 73, 72);">@RequestMapping#consumes</font> | <font style="color:rgb(76, 73, 72);">消费媒体类型</font> | <font style="color:rgb(76, 73, 72);">请求头 Content-Type 媒体类型映射</font> |
| <font style="color:rgb(76, 73, 72);">@RequestMapping#produces</font> | <font style="color:rgb(76, 73, 72);">生产媒体类型</font> | <font style="color:rgb(76, 73, 72);">响应头 Content-Type 媒体类型映射</font> |
| <font style="color:rgb(76, 73, 72);">HttpMessageConverter</font> | <font style="color:rgb(76, 73, 72);">HTTP消息转换器接口</font> | <font style="color:rgb(76, 73, 72);">HTTP 消息转换器，用于反序列化 HTTP 请求或序列化响应</font> |
| <font style="color:rgb(76, 73, 72);">WebMvcConfigurer</font> | <font style="color:rgb(76, 73, 72);">Web MVC 配置器</font> | <font style="color:rgb(76, 73, 72);">配置 REST 相关的组件</font> |
| <font style="color:rgb(76, 73, 72);">HandlerMethod</font> | <font style="color:rgb(76, 73, 72);">处理方法</font> | <font style="color:rgb(76, 73, 72);">@RequestMapping 标注的方法</font> |
| <font style="color:rgb(76, 73, 72);">HandlerMethodArgumentResolver</font> | <font style="color:rgb(76, 73, 72);">处理方法参数解析器</font> | <font style="color:rgb(76, 73, 72);">用于 HTTP 请求中解析 HandlerMethod 参数内容</font> |
| <font style="color:rgb(76, 73, 72);">HandlerMethodReturnValueHandler</font> | <font style="color:rgb(76, 73, 72);">处理方法返回值解析器</font> | <font style="color:rgb(76, 73, 72);">用于 HandlerMethod 返回值解析为 HTTP 响应内容</font> |


`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">为HTTP消息转换接口，Spring根据不同的媒体类型进行了相应的实现。比如上图中Accept为application/json，所以在第7步中，会选择使用</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的实现类</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">MappingJackson2HttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">来处理返回值。</font>

<h2 id="自定义HttpMessageConverter"><font style="color:rgb(76, 73, 72);">自定义HttpMessageConverter</font></h2>
<font style="color:rgb(76, 73, 72);">除了Spring给我们提供的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">实现外，我们也可以自定义</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的实现，来处理一些实际业务需求。</font>

<font style="color:rgb(76, 73, 72);">假如现在要实现一个用于处理 Content-Type 为 text/properties 媒体类型的 HttpMessageConverter 实现类 PropertiesHttpMessageConverter，当我们在请求体中传输下面内容时：</font>

```plain
name:mrbrid
age:18
```

<font style="color:rgb(76, 73, 72);">能够自动转换为Properties对象。</font>

<font style="color:rgb(76, 73, 72);">我们可以参照</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">MappingJackson2HttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的实现方式来进行实现，查看</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">MappingJackson2HttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的原型图：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713469530-cd67efb4-cb9f-403e-91f1-db5d8a40f920.png)

<font style="color:rgb(76, 73, 72);">所以我们可以通过继承</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">AbstractGenericHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的方式来实现</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">接口。</font>

<font style="color:rgb(76, 73, 72);">新建Spring Boot项目，版本为2.1.0.RELEASE，并引入</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">spring-boot-starter-web</font>_`<font style="color:rgb(76, 73, 72);">依赖，项目结构如下所示:</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713469508-7ce4218d-db85-44dd-8d0e-b319165d62fa.png)

<font style="color:rgb(76, 73, 72);">我们在</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">com.example.demo</font>_`<font style="color:rgb(76, 73, 72);">路径下新建</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">converter</font>_`<font style="color:rgb(76, 73, 72);">包，然后创建</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">，继承</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">AbstractGenericHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">：</font>

```java
public class PropertiesHttpMessageConverter extends AbstractGenericHttpMessageConverter<Properties> {
    @Override
    protected void writeInternal(Properties properties, Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {

    }
    @Override
    protected Properties readInternal(Class<? extends Properties> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {
        return null;
    }
    @Override
    public Properties read(Type type, Class<?> contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {
        return null;
    }
}
```

<font style="color:rgb(76, 73, 72);">其中</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">readxxx</font>_`<font style="color:rgb(76, 73, 72);">为反序列化过程，即将HTTP请求反序列化为参数的过程；</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">writeInternal</font>_`<font style="color:rgb(76, 73, 72);">为序列化过程，将响应序列化。</font>

<h3 id="反序列化过程"><font style="color:rgb(76, 73, 72);">反序列化过程</font></h3>
<font style="color:rgb(76, 73, 72);">我们继续编写</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">：</font>

```java
public class PropertiesHttpMessageConverter extends AbstractGenericHttpMessageConverter<Properties> {

    @Override
    protected void writeInternal(Properties properties, Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {

    }

    @Override
    protected Properties readInternal(Class<? extends Properties> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {
        Properties properties = new Properties();
        // 获取请求头
        HttpHeaders headers = inputMessage.getHeaders();
        // 获取 content-type
        MediaType contentType = headers.getContentType();
        // 获取编码
        Charset charset = null;
        if (contentType != null) {
            charset = contentType.getCharset();
        }

        charset = charset == null ? Charset.forName("UTF-8") : charset;

        // 获取请求体
        InputStream body = inputMessage.getBody();
        InputStreamReader inputStreamReader = new InputStreamReader(body, charset);

        properties.load(inputStreamReader);
        return properties;
    }

    @Override
    public Properties read(Type type, Class<?> contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {
        return readInternal(null, inputMessage);
    }
}
```

<font style="color:rgb(76, 73, 72);">在</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">readInternal</font>_`<font style="color:rgb(76, 73, 72);">方法中，我们获取了HTTP请求体中的输入流和编码，然后调用Properties对象的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">load</font>_`<font style="color:rgb(76, 73, 72);">方法来将流转换为Properties对象。反序列化过程完成了，我们还需将</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">添加到</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">集合中。</font>

<font style="color:rgb(76, 73, 72);">在</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">com.example.demo</font>_`<font style="color:rgb(76, 73, 72);">路径下新建</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">config</font>_`<font style="color:rgb(76, 73, 72);">包，然后创建</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">WebConfigurer</font>_`<font style="color:rgb(76, 73, 72);">配置类：</font>

```java
@Configuration
public class WebConfigurer implements WebMvcConfigurer {

    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        converters.add(new PropertiesHttpMessageConverter());
    }
}
```

`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">extendMessageConverters</font>_`<font style="color:rgb(76, 73, 72);">方法为</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">WebMvcConfigurer</font>_`<font style="color:rgb(76, 73, 72);">的默认方法，这里我们重写这个方法，用于将</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">添加到消息转换器集合中。</font>

<font style="color:rgb(76, 73, 72);">接着创建一个Controller来测试一波，在</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">com.example.demo</font>_`<font style="color:rgb(76, 73, 72);">路径下新建</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">controller</font>_`<font style="color:rgb(76, 73, 72);">包，然后创建</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">TestController</font>_`<font style="color:rgb(76, 73, 72);">：</font>

```java
@RestController
public class TestController {

    @GetMapping(value = "test", consumes = "text/properties")
    public Properties test(@RequestBody Properties properties) {
        return properties;
    }
}
```

<font style="color:rgb(76, 73, 72);">我们通过</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">@GetMapping</font>_`<font style="color:rgb(76, 73, 72);">注解的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">consumes</font>_`<font style="color:rgb(76, 73, 72);">属性指定了方法接收的媒体类型为</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">text/properties</font>_`<font style="color:rgb(76, 73, 72);">，如果方法能够成功被调用，并且可以返回</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">Properties</font>_`<font style="color:rgb(76, 73, 72);">对象，则说明我们自定义的HTTP消息转换器是可行的。</font>

<font style="color:rgb(76, 73, 72);">启动项目，使用PostMan访问：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713469625-57df4820-a701-469c-9a36-3fd210a5dc0f.png)

<font style="color:rgb(76, 73, 72);">请求头中指定Content-Type为text/properties，请求体内容如下所示:</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713471617-aa76b5fd-1fc0-4420-8ef5-747295fa3819.png)

<font style="color:rgb(76, 73, 72);">访问后，控制台输出错误如下：</font>

```bash
Resolved [org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing: public java.util.Properties com.example.demo.controller.TestController.test(java.util.Properties)]
```

<font style="color:rgb(76, 73, 72);">为什么呢？因为我们在自定义</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的时候需要在其构造器中指定它能够处理的媒体类型，我们查看</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">MappingJackson2HttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的构造器，看看它是怎么实现的：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713472065-619b00cb-2d61-488e-945e-1d030d96acdf.png)

<font style="color:rgb(76, 73, 72);">所以我们在</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的构造器中添加相应的媒体类型：</font>

```java
public PropertiesHttpMessageConverter() {
    super(new MediaType("text", "properties"));
}
```

<font style="color:rgb(76, 73, 72);">这时候，重启项目，再次访问上面的请求，可看到响应如下所示:</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713472271-8db3a8bf-32c8-44e2-b62b-84fbb25d198c.png)

<h3 id="序列化过程"><font style="color:rgb(76, 73, 72);">序列化过程</font></h3>
<font style="color:rgb(76, 73, 72);">序列化的过程就是处理HTTP响应的过程，对应</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">writeInternal</font>_`<font style="color:rgb(76, 73, 72);">方法。那为什么我们都还实现这个方法，上面的Controller请求却能返回正常的JSON内容呢？两个原因：</font>

1. <font style="color:rgb(76, 73, 72);">这里我们定义的是REST接口，所以响应默认会被序列化为JSON格式；</font>
2. <font style="color:rgb(76, 73, 72);">由于使用</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">converters.add(new PropertiesHttpMessageConverter());</font>_`<font style="color:rgb(76, 73, 72);">这种方式来添加自定义HTTP消息处理器默认会被添加到集合的末尾，在处理JSON响应的时候被排在前面的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">MappingJackson2HttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">优先处理了。</font>

<font style="color:rgb(76, 73, 72);">我们可以通过debug来查看</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">是否真的被添加到集合末尾了：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713472936-6c9b9d77-2003-4545-bcee-3689be59abff.png)

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713473926-95075bf6-221e-4e6a-a20f-f478121bb0fe.png)

<font style="color:rgb(76, 73, 72);">所以我们要换下面这种方式来添加自定义HTTP处理器：</font>

```java
@Configuration
public class WebConfigurer implements WebMvcConfigurer {

    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        // converters.add(new PropertiesHttpMessageConverter());
        // 指定顺序，这里为第一个
        converters.add(0, new PropertiesHttpMessageConverter());
    }
}
```

<font style="color:rgb(76, 73, 72);">我们重启项目，再次debug：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713474084-7a8c93fe-b2aa-4c27-93e0-4e03fe608910.png)

<font style="color:rgb(76, 73, 72);">可看到，</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">已经排在第一个了。这时候再次访问上面的请求，响应如下所示:</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713474125-6058e3f2-8f10-4063-91f1-f7a7580cb988.png)

<font style="color:rgb(76, 73, 72);">没有任何返回值，这是因为我们还没实现</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">writeInternal</font>_`<font style="color:rgb(76, 73, 72);">呢。继续实现</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">writeInternal</font>_`<font style="color:rgb(76, 73, 72);">方法：</font>

```java
public class PropertiesHttpMessageConverter extends AbstractGenericHttpMessageConverter<Properties> {

    ...

    @Override
    protected void writeInternal(Properties properties, Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
        // 获取请求头
        HttpHeaders headers = outputMessage.getHeaders();
        // 获取 content-type
        MediaType contentType = headers.getContentType();
        // 获取编码
        Charset charset = null;
        if (contentType != null) {
            charset = contentType.getCharset();
        }

        charset = charset == null ? Charset.forName("UTF-8") : charset;

        // 获取请求体
        OutputStream body = outputMessage.getBody();
        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(body, charset);

        properties.store(outputStreamWriter, "Serialized by PropertiesHttpMessageConverter#writeInternal");
    }

    ...
}
```

<font style="color:rgb(76, 73, 72);">过程和反序化差不多，这里是通过</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">Properties</font>_`<font style="color:rgb(76, 73, 72);">对象的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">store</font>_`<font style="color:rgb(76, 73, 72);">方法来进行写操作。</font>

<font style="color:rgb(76, 73, 72);">重启项目，再次访问上面的请求，响应如下所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713474193-80f6ee31-15b0-4589-b2eb-d299f4d4959c.png)

<h2 id="自定义HandlerMethodArgumentResolver"><font style="color:rgb(76, 73, 72);">自定义HandlerMethodArgumentResolver</font></h2>
<font style="color:rgb(76, 73, 72);">上面这种方式必须依赖于</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">@RequestBody</font>_`<font style="color:rgb(76, 73, 72);">和</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">@ResponseBody</font>_`<font style="color:rgb(76, 73, 72);">注解，除此之外我们还可以通过自定义</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">和</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HandlerMethodReturnValueHandler</font>_`<font style="color:rgb(76, 73, 72);">实现类的方式来处理内容协商。</font>

`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">俗称方法参数解析器，用于解析由</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">@RequestMapping</font>_`<font style="color:rgb(76, 73, 72);">注解（或其派生的注解）所标注的方法的参数。这里我们开始通过实现</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">的方式来将HTTP请求体的内容自动解析为Properties对象。</font>

<font style="color:rgb(76, 73, 72);">在</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">com.example.demo</font>_`<font style="color:rgb(76, 73, 72);">路径下新建</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">resolver</font>_`<font style="color:rgb(76, 73, 72);">包，然后创建</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHandlerMethodReturnValueHandler</font>_`<font style="color:rgb(76, 73, 72);">实现</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">接口：</font>

```java
public class PropertiesHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver {
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return Properties.class.equals(parameter.getParameterType());
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        ServletWebRequest servletWebRequest = (ServletWebRequest) webRequest;
        HttpServletRequest request = servletWebRequest.getRequest();
        String contentType = request.getHeader("Content-Type");

        MediaType mediaType = MediaType.parseMediaType(contentType);
        // 获取编码
        Charset charset = mediaType.getCharset() == null ? Charset.forName("UTF-8") : mediaType.getCharset();
        // 获取输入流
        InputStream inputStream = request.getInputStream();
        InputStreamReader inputStreamReader = new InputStreamReader(inputStream, charset);

        // 输入流转换为 Properties
        Properties properties = new Properties();
        properties.load(inputStreamReader);
        return properties;
    }
}
```

<font style="color:rgb(76, 73, 72);">方法</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">supportsParameter</font>_`<font style="color:rgb(76, 73, 72);">用于指定支持解析的参数类型，这里为Properties类型。</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">resolveArgument</font>_`<font style="color:rgb(76, 73, 72);">方法用于实现解析逻辑，解析过程和上面定义的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">readInternal</font>_`<font style="color:rgb(76, 73, 72);">方法类似。</font>

<font style="color:rgb(76, 73, 72);">接着，我们还需将</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">添加到Spring自带的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">实现类集合中。值得注意的是，我们不能在配置类</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">WebMvcConfigurer</font>_`<font style="color:rgb(76, 73, 72);">中通过重写</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">addArgumentResolvers</font>_`<font style="color:rgb(76, 73, 72);">的方式来添加，查看该方法源码上的注释：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713476257-d64213a8-d885-492e-b511-029222b68d9f.png)

<font style="color:rgb(76, 73, 72);">大致意思是通过这个方法来添加的方法参数解析器不会覆盖Spring内置的方法参数解析器，如果需要这么做的话，可以直接通过修改</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">RequestMappingHandlerAdapter</font>_`<font style="color:rgb(76, 73, 72);">来实现。</font>

<font style="color:rgb(76, 73, 72);">所以我们可以通过下面这个方式来实现：</font>

```java
@Configuration
public class WebConfigurer implements WebMvcConfigurer {


    @Autowired
    private RequestMappingHandlerAdapter requestMappingHandlerAdapter;

    @PostConstruct
    public void init() {
        // 获取当前 RequestMappingHandlerAdapter 所有的 ArgumentResolver对象
        List<HandlerMethodArgumentResolver> argumentResolvers = requestMappingHandlerAdapter.getArgumentResolvers();
        List<HandlerMethodArgumentResolver> newArgumentResolvers = new ArrayList<>(argumentResolvers.size() + 1);
        // 添加 PropertiesHandlerMethodArgumentResolver 到集合第一个位置
        newArgumentResolvers.add(0, new PropertiesHandlerMethodArgumentResolver());
        // 将原 ArgumentResolver 添加到集合中
        newArgumentResolvers.addAll(argumentResolvers);
        // 重新设置 ArgumentResolver对象集合
        requestMappingHandlerAdapter.setArgumentResolvers(newArgumentResolvers);
    }
}
```

<font style="color:rgb(76, 73, 72);">我们在</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">WebConfigurer</font>_`<font style="color:rgb(76, 73, 72);">配置类装配完毕的时候，通过</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">requestMappingHandlerAdapter</font>_`<font style="color:rgb(76, 73, 72);">对象的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">setArgumentResolvers</font>_`<font style="color:rgb(76, 73, 72);">方法来重新设置方法解析器集合，将</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">添加到集合的第一个位置。</font>

<font style="color:rgb(76, 73, 72);">之所以要将</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">添加到第一个位置是因为Properties本质也是一个Map对象，而Spring内置的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">MapMethodProcessor</font>_`<font style="color:rgb(76, 73, 72);">就是用于处理Map参数类型的，如果不将</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">优先级提高，那么Properties类型参数会被</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">MapMethodProcessor</font>_`<font style="color:rgb(76, 73, 72);">解析，从而出错。</font>

<font style="color:rgb(76, 73, 72);">配置完毕后，我们改造一下</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">TestController</font>_`<font style="color:rgb(76, 73, 72);">：</font>

```java
// @RestController
@Controller
public class TestController {

    @GetMapping(value = "test", consumes = "text/properties")
    @ResponseBody
    public Properties test(@RequestBody Properties properties) {
        return properties;
    }

    @GetMapping(value = "test1", consumes = "text/properties")
    @ResponseBody
    public Properties test1(Properties properties) {
        return properties;
    }
}
```

`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">test1</font>_`<font style="color:rgb(76, 73, 72);">方法的参数没有被</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">@RequestBody</font>_`<font style="color:rgb(76, 73, 72);">标注，启动项目，访问下面这个请求：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713477982-d1c13939-327a-476d-9a35-2951b50d7666.png)

<font style="color:rgb(76, 73, 72);">可以看到方法成功执行，并且返回了正确的内容，说明我们自定义的方法参数解析器</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">是可行的。</font>

<font style="color:rgb(76, 73, 72);">但是方法的返回值还是由</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">writeInternal</font>_`<font style="color:rgb(76, 73, 72);">方法解析的，并且依赖于</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">@ResponseBody</font>_`<font style="color:rgb(76, 73, 72);">注解，接着我们开始实现自定义方法返回值解析器，并且不依赖于</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">@ResponseBody</font>_`<font style="color:rgb(76, 73, 72);">注解。</font>

<h2 id="自定义HandlerMethodReturnValueHandler"><font style="color:rgb(76, 73, 72);">自定义HandlerMethodReturnValueHandler</font></h2>
`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">俗称方法返回值解析器，用于解析由</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">@RequestMapping</font>_`<font style="color:rgb(76, 73, 72);">注解（或其派生的注解）所标注的方法的返回值。这里我们开始通过实现</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HandlerMethodReturnValueHandler</font>_`<font style="color:rgb(76, 73, 72);">的方式来自定义一个用于处理返回值类型为Properties类型的解析器。</font>

<font style="color:rgb(76, 73, 72);">在</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">com.example.demo</font>_`<font style="color:rgb(76, 73, 72);">路径下新建</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">handler</font>_`<font style="color:rgb(76, 73, 72);">包，然后创建</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHandlerMethodReturnValueHandler</font>_`<font style="color:rgb(76, 73, 72);">实现</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HandlerMethodReturnValueHandler</font>_`<font style="color:rgb(76, 73, 72);">：</font>

```java
public class PropertiesHandlerMethodReturnValueHandler implements HandlerMethodReturnValueHandler {

    @Override
    public boolean supportsReturnType(MethodParameter returnType) {
        return Properties.class.equals(returnType.getMethod().getReturnType());
    }

    @Override
    public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
        Properties properties = (Properties) returnValue;

        ServletWebRequest servletWebRequest = (ServletWebRequest) webRequest;

        HttpServletResponse response = servletWebRequest.getResponse();
        ServletServerHttpResponse servletServerHttpResponse = new ServletServerHttpResponse(response);

        // 获取请求头
        HttpHeaders headers = servletServerHttpResponse.getHeaders();

        MediaType contentType = headers.getContentType();
        // 获取编码
        Charset charset = null;
        if (contentType != null) {
            charset = contentType.getCharset();
        }

        charset = charset == null ? Charset.forName("UTF-8") : charset;

        // 获取请求体
        OutputStream body = servletServerHttpResponse.getBody();
        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(body, charset);

        properties.store(outputStreamWriter, "Serialized by PropertiesHandlerMethodReturnValueHandler#handleReturnValue");
    }
}
```

`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">supportsReturnType</font>_`<font style="color:rgb(76, 73, 72);">方法指定了处理返回值的类型，</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">handleReturnValue</font>_`<font style="color:rgb(76, 73, 72);">方法用于处理返回值，这里的逻辑和</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHttpMessageConverter</font>_`<font style="color:rgb(76, 73, 72);">的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">writeInternal</font>_`<font style="color:rgb(76, 73, 72);">方法基本一致，不再赘述。</font>

<font style="color:rgb(76, 73, 72);">接着将</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHandlerMethodReturnValueHandler</font>_`<font style="color:rgb(76, 73, 72);">添加到到Spring自带的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HandlerMethodReturnValueHandler</font>_`<font style="color:rgb(76, 73, 72);">实现类集合中，添加方式和自定义</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">HandlerMethodArgumentResolver</font>_`<font style="color:rgb(76, 73, 72);">一致：</font>

```java
@Configuration
public class WebConfigurer implements WebMvcConfigurer {


    @Autowired
    private RequestMappingHandlerAdapter requestMappingHandlerAdapter;

    @PostConstruct
    public void init() {
        // 获取当前 RequestMappingHandlerAdapter 所有的 ArgumentResolver对象
        List<HandlerMethodArgumentResolver> argumentResolvers = requestMappingHandlerAdapter.getArgumentResolvers();
        List<HandlerMethodArgumentResolver> newArgumentResolvers = new ArrayList<>(argumentResolvers.size() + 1);
        // 添加 PropertiesHandlerMethodArgumentResolver 到集合第一个位置
        newArgumentResolvers.add(0, new PropertiesHandlerMethodArgumentResolver());
        // 将原 ArgumentResolver 添加到集合中
        newArgumentResolvers.addAll(argumentResolvers);
        // 重新设置 ArgumentResolver对象集合
        requestMappingHandlerAdapter.setArgumentResolvers(newArgumentResolvers);

        // 获取当前 RequestMappingHandlerAdapter 所有的 returnValueHandlers对象
        List<HandlerMethodReturnValueHandler> returnValueHandlers = requestMappingHandlerAdapter.getReturnValueHandlers();
        List<HandlerMethodReturnValueHandler> newReturnValueHandlers = new ArrayList<>(returnValueHandlers.size() + 1);
        // 添加 PropertiesHandlerMethodReturnValueHandler 到集合第一个位置
        newReturnValueHandlers.add(0, new PropertiesHandlerMethodReturnValueHandler());
        // 将原 returnValueHandlers 添加到集合中
        newReturnValueHandlers.addAll(returnValueHandlers);
        // 重新设置 ReturnValueHandlers对象集合
        requestMappingHandlerAdapter.setReturnValueHandlers(newReturnValueHandlers);
    }
}
```

<font style="color:rgb(76, 73, 72);">配置好后，我们将</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">TestController</font>_`<font style="color:rgb(76, 73, 72);">的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">test1</font>_`<font style="color:rgb(76, 73, 72);">方法的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">@ResponseBody</font>_`<font style="color:rgb(76, 73, 72);">注解去掉，重启项目，再次访问:</font>

![](https://cdn.nlark.com/yuque/0/2024/png/48200602/1734713478891-99824820-c76e-448f-b003-34e53ccc57d8.png)

<font style="color:rgb(76, 73, 72);">可以看到，返回值成功被</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHandlerMethodReturnValueHandler</font>_`<font style="color:rgb(76, 73, 72);">的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">handleReturnValue</font>_`<font style="color:rgb(76, 73, 72);">方法解析了。</font>

<font style="color:rgb(76, 73, 72);">但是这里还有一个问题，我们查看控制台，会发现如下异常:</font>

```bash
javax.servlet.ServletException: Circular view path [test1]: would dispatch back to the current handler URL [/test1] again. Check your ViewResolver setup! (Hint: This may be the result of an unspecified view, due to default view name generation.)
	at org.springframework.web.servlet.view.InternalResourceView.prepareForRendering(InternalResourceView.java:209) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:147) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:316) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1370) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1116) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1055) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:998) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:890) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:875) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) ~[tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:770) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_171]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_171]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.12.jar:9.0.12]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_171]
```

<font style="color:rgb(76, 73, 72);">这是因为，在Spring中如果Controller中的方法没有被</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">@ResponseBody</font>_`<font style="color:rgb(76, 73, 72);">标注的话，默认会把返回值当成视图的名称，而这里我们并不希望解析的Properties值被当成视图名称，所以我们需要在</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">PropertiesHandlerMethodReturnValueHandler</font>_`<font style="color:rgb(76, 73, 72);">的</font>`_<font style="color:rgb(65, 74, 81);background-color:rgb(251, 251, 251);">handleReturnValue</font>_`<font style="color:rgb(76, 73, 72);">方法最后一行添加如下代码：</font>

```java
// 告诉 Spring MVC 请求已经处理完毕
mavContainer.setRequestHandled(true);
```

<font style="color:rgb(76, 73, 72);">这行代码告诉Spring，请求已经成功完成了，无需进行后续的处理。重启项目再次访问上面的请求，控制台便不再抛异常了。</font>

<font style="color:rgb(102, 102, 102);">源码链接：</font>[<font style="color:rgb(102, 102, 102);">https://github.com/wuyouzhuguli/SpringAll/tree/master/47.Spring-Boot-Content-Negotiation</font>](https://github.com/wuyouzhuguli/SpringAll/tree/master/47.Spring-Boot-Content-Negotiation)

